// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

//! The module includes the definitions of data structures according to SEV-SNP specification.

use bitfield_struct::bitfield;
use zerocopy::FromBytes;
use zerocopy::FromZeros;
use zerocopy::Immutable;
use zerocopy::IntoBytes;
use zerocopy::KnownLayout;

/// Ioctl type defined by Linux.
pub const SNP_GUEST_REQ_IOC_TYPE: u8 = b'S';

/// Value for the `msg_version` member in [`SNP_GUEST_REQ_MSG_VERSION`].
/// Use 1 for now.
pub const SNP_GUEST_REQ_MSG_VERSION: u32 = 1;

/// Ioctl struct defined by Linux.
#[repr(C)]
pub struct SnpGuestRequestIoctl {
    /// Message version number (must be non-zero).
    pub msg_version: u32,
    /// Request struct address.
    pub req_data: u64,
    /// Response struct address.
    pub resp_data: u64,
    /// VMM error code.
    pub exitinfo: VmmErrorCode,
}

/// VMM error code.
#[repr(C)]
#[derive(FromZeros, Immutable, KnownLayout)]
pub struct VmmErrorCode {
    /// Firmware error
    pub fw_error: u32,
    /// VMM error
    pub vmm_error: u32,
}

#[repr(C)]
pub struct TioGuestRequestIoctl {
    /// Message version number (must be non-zero).
    pub msg_version: u32,
    /// Request struct address.
    pub req_data: u64,
    /// Response struct address.
    pub resp_data: u64,
    /// VMM error code.
    pub exitinfo1: VmmErrorCode,
    /// [TDISP TODO] Exitinfo1
    pub exitinfo2: u64,
    /// [TDISP TODO] tio_msg type
    pub msg_type: u64,
    /// [TDISP TODO] req_size
    pub req_size: u64,
    /// [TDISP TODO] resp_size
    pub resp_size: u64,
    /// [TDISP TODO] pci_id
    pub pci_id: u64,
    /// [TDISP TODO] additional_arg / additional_arg
    pub additional_arg: u64,
}

/// Request structure for the `SNP_GET_REPORT` ioctl.
/// See `MSG_REPORT_REQ` in Table 21, "SEV Secure Nested Paging Firmware ABI specification", Revision 1.55.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SnpReportReq {
    /// Guest-provided data to be included in the attestation report.
    pub user_data: [u8; 64],
    /// The VMPL to put in the attestation report. Must be greater than
    /// or equal to the current VMPL and, at most, three.
    pub vmpl: u32,
    /// Reserved
    // TODO SNP: Support VLEK feature if needed
    pub rsvd: [u8; 28],
}

const SNP_REPORT_RESP_DATA_SIZE: usize =
    size_of::<u32>() + size_of::<u32>() + 24 + size_of::<SnpReport>();

/// The size of the response data defined by the Linux kernel.
const LINUX_SNP_REPORT_RESP_DATA_SIZE: usize = 4000;

/// Response structure for the `SNP_GET_REPORT` ioctl.
/// See `MSG_REPORT_RSP` in Table 24, "SEV Secure Nested Paging Firmware ABI specification", Revision 1.55.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SnpReportResp {
    /// The status of key derivation operation.
    /// 0h: Success.
    /// 16h: Invalid parameters.
    /// 27h: Invalid key selection.
    pub status: u32,
    /// Size in bytes of the report.
    pub report_size: u32,
    /// Reserved
    pub _reserved0: [u8; 24],
    /// The attestation report generated by the firmware.
    pub report: SnpReport,
    /// Reserved
    pub _reserved1: [u8; LINUX_SNP_REPORT_RESP_DATA_SIZE - SNP_REPORT_RESP_DATA_SIZE],
}

static_assertions::const_assert_eq!(LINUX_SNP_REPORT_RESP_DATA_SIZE, size_of::<SnpReportResp>());

/// Size of the [`SnpReport`].
pub const SNP_REPORT_SIZE: usize = 0x4a0;

/// Size of `report_data` member in [`SnpReport`].
pub const SNP_REPORT_DATA_SIZE: usize = 64;

/// Report structure.
/// See `ATTESTATION_REPORT` in Table 22, "SEV Secure Nested Paging Firmware ABI specification", Revision 1.55.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SnpReport {
    /// Version number of this attestation report.
    /// Set to 2h for this specification.
    pub version: u32,
    /// The guest SVN.
    pub guest_svn: u32,
    /// The guest policy.
    pub policy: u64,
    /// The family ID provided at launch.
    pub family: u128,
    /// The image ID provided at launch.
    pub image_id: u128,
    /// The request VMPL for the attestation
    /// report.
    pub vmpl: u32,
    /// The signature algorithm used to sign
    /// this report.
    pub signature_algo: u32,
    /// CurrentTcb.
    pub current_tcb: u64,
    /// Information about the platform.
    pub platform_info: u64,
    /// Flags
    pub flags: u32,
    /// Reserved
    pub _reserved0: u32,
    /// Guest-provided data.
    pub report_data: [u8; SNP_REPORT_DATA_SIZE],
    /// The measurement calculated at
    /// launch.
    pub measurement: [u8; 48],
    /// Data provided by the hypervisor at
    /// launch.
    pub host_data: [u8; 32],
    /// SHA-384 digest of the ID public key
    /// that signed the ID block provided in
    /// SNP_LAUNCH_FINISH.
    pub id_key_digest: [u8; 48],
    /// SHA-384 digest of the Author public
    /// key that certified the ID key, if
    /// provided in SNP_LAUNCH_FINISH.
    pub author_key_digest: [u8; 48],
    /// Report ID of this guest.
    pub report_id: [u8; 32],
    /// Report ID of this guestâ€™s migration
    /// agent
    pub report_id_ma: [u8; 32],
    /// Reported TCB version used to derive
    /// the VCEK that signed this report.
    pub reported_tcb: u64,
    /// Reserved
    pub _reserved1: [u8; 24],
    /// If MaskChipId is set to 0, Identifier
    /// unique to the chip as output by
    /// GET_ID. Otherwise, set to 0h.
    pub chip_id: [u8; 64],
    /// CommittedTcb.
    pub committed_tcb: u64,
    /// The build number of CurrentVersion.
    pub current_build: u8,
    /// The minor number of CurrentVersion.
    pub current_minor: u8,
    /// The major number of CurrentVersion.
    pub current_major: u8,
    /// Reserved
    pub _reserved2: u8,
    /// The build number of CommittedVersion.
    pub committed_build: u8,
    /// The minor version of CommittedVersion.
    pub committed_minor: u8,
    /// The major version of CommittedVersion.
    pub committed_major: u8,
    /// Reserved
    pub _reserved3: u8,
    /// The CurrentTcb at the time the guest
    /// was launched or imported.
    pub launch_tcb: u64,
    /// Reserved
    pub _reserved4: [u8; 168],
    /// Signature of bytes inclusive of this report.
    pub signature: [u8; 512],
}

static_assertions::const_assert_eq!(SNP_REPORT_SIZE, size_of::<SnpReport>());

/// Request structure for the `SNP_GET_DERIVED_KEY` ioctl.
/// See `MSG_KEY_REQ` in Table 18, "SEV Secure Nested Paging Firmware ABI specification", Revision 1.55.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SnpDerivedKeyReq {
    /// Selects the root key from which to derive the key.
    /// 0 indicates VCEK
    /// 1 indicates VMRK
    // TODO: Support VLEK feature if needed
    pub root_key_select: u32,
    /// Reserved
    pub rsvd: u32,
    /// Bitmask indicating which data will be mixed into the
    /// derived key.
    pub guest_field_select: u64,
    /// The VMPL to mix into the derived key. Must be greater
    /// than or equal to the current VMPL.
    pub vmpl: u32,
    /// The guest SVN to mix into the key. Must not exceed the
    /// guest SVN provided at launch in the ID block.
    pub guest_svn: u32,
    /// The TCB version to mix into the derived key. Must not
    /// exceed CommittedTcb.
    pub tcb_version: u64,
}

/// See `TIO_MSG_TDI_INFO_REQ` in Table 60, "SEV-TIO Firmware Interface Specification", Revision 0.91.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgTdiInfoReq {
    /// Hypervisor supplied guest id.
    pub guest_device_id: u16,
    /// Reserved
    pub _reserved0: [u8; 14],
}

static_assertions::const_assert_eq!(16, size_of::<TioMsgTdiInfoReq>());

/// See `TIO_MSG_TDI_INFO_RSP` in Table 61, "SEV-TIO Firmware Interface Specification", Revision 0.91.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgTdiInfoRsp {
    /// Hypervisor supplied guest id.
    pub guest_device_id: u16,
    /// TDI status.
    pub tdi_status: u16,
    /// Reserved
    pub _reserved0: [u8; 12],
    /// MEAS_DIGEST info
    pub meas_digest_info: u32,
    /// Device lock flags
    pub lock_flags: u32,
    /// SPDM algorithms
    pub spdm_algos: u64,
    /// Certs digest
    pub certs_digest: [u8; 48],
    /// MEAS digest
    pub meas_digest: [u8; 48],
    /// Interface report digest
    pub interface_report_digest: [u8; 48],
    /// Tdi report count
    pub tdi_report_count: u64,
    /// Reserved
    pub _reserved1: u64,
}

// Assert the size of the response field
static_assertions::const_assert_eq!(192, size_of::<TioMsgTdiInfoRsp>());

#[bitfield(u16)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct TioMsgMmioValidateReqFlags {
    /// Desired value to set RMP. Validated for the range.
    pub validated: bool,

    /// 0: If subrange does not have RMP. Validated
    /// set uniformly, fail.
    /// 1: If subrange does not have RMP. Validated
    /// set uniformly, force to requested value.
    pub force_validated: bool,

    #[bits(14)]
    _reserved0: u16,
}

/// See `TIO_MSG_MMIO_VALIDATE_REQ` in Table 63, "SEV-TIO Firmware Interface Specification", Revision 0.91.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgMmioValidateReq {
    /// Hypervisor provided identifier used by the guest to identify the TDI in guest messages.
    pub guest_device_id: u16,
    /// Reserved.
    pub _reserved0: [u8; 14],
    /// Guest physical address of the subrange.
    pub subrange_base: u64,
    /// Number of 4 KB pages in the subrange.
    pub subrange_page_count: u32,
    /// Offset of the subrange within the MMIO range.
    pub range_offset: u32,
    /// Validated flags
    pub validated_flags: TioMsgMmioValidateReqFlags,
    /// RangeID of MMIO range.
    pub range_id: u16,
    /// Reserved.
    pub _reserved2: [u8; 12],
}

// Assert the size of the structure
static_assertions::const_assert_eq!(48, size_of::<TioMsgMmioValidateReq>());

#[bitfield(u16)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct TioMsgMmioValidateResFlags {
    /// Indicates that the Validated bit has changed due to this operation.
    pub changed: bool,

    #[bits(15)]
    _reserved0: u16,
}

/// See `TIO_MSG_MMIO_VALIDATE_RSP` in Table 64, "SEV-TIO Firmware Interface Specification", Revision 0.91.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgMmioValidateRsp {
    /// Hypervisor provided PCIe Routing ID used by the guest to identify the TDI.
    pub guest_device_id: u16,
    /// Status of the operation.
    pub status: u16,
    /// Reserved.
    pub _reserved0: [u8; 12],
    /// Guest physical address of the subrange.
    pub subrange_base: u64,
    /// Number of 4 KB pages in the subrange.
    pub subrange_page_count: u32,
    /// Offset of the subrange within the MMIO range.
    pub range_offset: u32,
    /// Validated flags
    pub flag_bits: TioMsgMmioValidateResFlags,
    /// Range of the MMIO.
    pub range_id: u16,
    /// Reserved.
    pub _reserved2: [u8; 12],
}

// Assert the size of the structure
static_assertions::const_assert_eq!(48, size_of::<TioMsgMmioValidateRsp>());

#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgMmioConfigReq {
    /// Hypervisor provided identifier used by the guest to identify the TDI in guest messages.
    pub guest_device_id: u16,
    /// Reserved.
    pub _reserved0: [u8; 2],
    /// Flags for the range.
    pub flags: u16,
    /// Range ID of the MMIO range.
    pub range_id: u16,
    /// WRITE flag.
    pub write: u32,
    /// Reserved.
    pub _reserved2: [u8; 4],
}

impl TioMsgMmioConfigReq {
    /// 0: Can be mapped only into guest private
    /// memory.
    /// 1: Can be mapped into either guest
    /// private memory or shared memory.
    /// Ignored if WRITE is 0.
    pub fn is_non_tee_mem(&self) -> bool {
        (self.flags & (1 << 2)) != 0
    }
}

static_assertions::const_assert_eq!(16, size_of::<TioMsgMmioConfigReq>());

/// See `TIO_MSG_MMIO_CONFIG_RSP` in Table 66, "SEV-TIO Firmware Interface Specification", Revision 0.91.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgMmioConfigRsp {
    /// Hypervisor provided identifier used by the guest to identify the TDI in guest messages.
    pub guest_device_id: u16,
    /// Status of the operation.
    pub status: u16,
    /// Flags for the range.
    pub flags: u16,
    /// Range ID of the MMIO range.
    pub range_id: u16,
    /// WRITE flag.
    pub write: u32,
    /// Reserved.
    pub _reserved1: [u8; 4],
}

impl TioMsgMmioConfigRsp {
    /// Indicates if certain TDISP flags can be updated.
    pub fn is_mem_attr_updateable(&self) -> bool {
        (self.flags & (1 << 3)) != 0
    }

    /// Indicates if the range can be mapped into either guest private memory or shared memory.
    pub fn is_non_tee_mem(&self) -> bool {
        (self.flags & (1 << 2)) != 0
    }

    /// Indicates if this range maps MSI-X PBA.
    pub fn msix_pba(&self) -> bool {
        (self.flags & (1 << 1)) != 0
    }

    /// Indicates if the range maps MSI-X table.
    pub fn msix_table(&self) -> bool {
        (self.flags & 1) != 0
    }
}

static_assertions::const_assert_eq!(16, size_of::<TioMsgMmioConfigRsp>());

#[bitfield(u64)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SdtePart1 {
    // [0]
    pub v: bool,

    #[bits(60)]
    _reserved0: u64,

    pub ir: bool,

    pub iw: bool,

    _reserved1: bool,
}

#[bitfield(u64)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SdtePart2 {
    #[bits(49)]
    pub _reserved0: u64,

    #[bits(2)]
    pub vmpl: u64,

    #[bits(13)]
    _reserved1: u64,
}

#[bitfield(u64)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SdtePart3 {
    pub vtom_en: bool,

    #[bits(31)]
    pub virtual_tom: u32,

    #[bits(32)]
    _reserved1: u64,
}

#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
#[repr(C)]
pub struct Sdte {
    pub part1: SdtePart1,
    pub _reserved0: u64,
    pub _reserved1: u64,
    pub part2: SdtePart2,
    pub _reserved2: u64,
    pub part3: SdtePart3,
    pub _reserved3: u64,
    pub _reserved4: u64,
}

static_assertions::const_assert_eq!(size_of::<Sdte>(), 64);

#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgSdteWriteReq {
    /// Hypervisor provided identifier used by the guest to identify the TDI in guest messages.
    pub guest_device_id: u16,

    pub _reserved0: [u8; 14],

    /// sDTE to use to configure the guest controlled fields.
    pub sdte: Sdte,
}

static_assertions::const_assert_eq!(size_of::<TioMsgSdteWriteReq>(), 80);

/// See `TIO_MSG_SDTE_WRITE_RSP` in Table 69, "SEV-TIO Firmware Interface Specification", Revision 0.91.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes, Debug)]
pub struct TioMsgSdteWriteRsp {
    /// Hypervisor provided PCIe Routing ID used by the guest to identify the TDI.
    pub guest_device_id: u16,
    /// Status of the operation.
    pub status: u16,
    /// Reserved.
    pub _reserved0: [u8; 12],
}

static_assertions::const_assert_eq!(size_of::<TioMsgSdteWriteRsp>(), 16);

/// Indicate which guest-selectable fields will be mixed into the key.
/// See `GUEST_FIELD_SELECT` in Table 19, "SEV Secure Nested Paging Firmware ABI specification", Revision 1.55.
#[bitfield(u64)]
pub struct GuestFieldSelect {
    /// Indicate that the guest policy will be mixed into the key.
    pub guest_policy: bool,
    /// Indicate that the image ID of the guest will be mixed into the key.
    pub image_id: bool,
    /// Indicate the family ID of the guest will be mixed into the key.
    pub family_id: bool,
    /// Indicate the measurement of the guest during launch will be mixed into the key.
    pub measurement: bool,
    /// Indicate that the guest-provided SVN will be mixed into the key.
    pub guest_svn: bool,
    /// Indicate that the guest-provided TCB_VERSION will be mixed into the key.
    pub tcb_version: bool,
    /// Reserved
    #[bits(58)]
    pub _reserved: u64,
}

/// See `DERIVED_KEY` in Table 20, "SEV Secure Nested Paging Firmware ABI specification", Revision 1.55.
pub const SNP_DERIVED_KEY_SIZE: usize = 32;

/// Response structure for the `SNP_GET_DERIVED_KEY` ioctl.
/// See `MSG_KEY_RSP` in Table 20, "SEV Secure Nested Paging Firmware ABI specification", Revision 1.55.
#[repr(C)]
#[derive(IntoBytes, Immutable, KnownLayout, FromBytes)]
pub struct SnpDerivedKeyResp {
    /// The status of key derivation operation.
    /// 0h: Success.
    /// 16h: Invalid parameters.
    /// 27h: Invalid key selection.
    pub status: u32,
    /// Reserved
    pub _reserved: [u8; 28],
    /// The requested derived key.
    pub derived_key: [u8; SNP_DERIVED_KEY_SIZE],
}

static_assertions::const_assert_eq!(
    // The size of the response data defined by the Linux kernel.
    64,
    size_of::<SnpDerivedKeyResp>()
);
